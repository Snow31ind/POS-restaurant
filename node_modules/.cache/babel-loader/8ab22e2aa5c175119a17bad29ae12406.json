{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar tslib = require('tslib');\n\nvar heyListen = require('hey-listen');\n\nvar styleValueTypes = require('style-value-types');\n\nvar sync = require('framesync');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar sync__default = /*#__PURE__*/_interopDefaultLegacy(sync);\n\nconst clamp = (min, max, v) => Math.min(Math.max(v, min), max);\n\nconst safeMin = 0.001;\nconst minDuration = 0.01;\nconst maxDuration = 10.0;\nconst minDamping = 0.05;\nconst maxDamping = 1;\n\nfunction findSpring({\n  duration = 800,\n  bounce = 0.25,\n  velocity = 0,\n  mass = 1\n}) {\n  let envelope;\n  let derivative;\n  heyListen.warning(duration <= maxDuration * 1000, \"Spring duration must be 10 seconds or less\");\n  let dampingRatio = 1 - bounce;\n  dampingRatio = clamp(minDamping, maxDamping, dampingRatio);\n  duration = clamp(minDuration, maxDuration, duration / 1000);\n\n  if (dampingRatio < 1) {\n    envelope = undampedFreq => {\n      const exponentialDecay = undampedFreq * dampingRatio;\n      const delta = exponentialDecay * duration;\n      const a = exponentialDecay - velocity;\n      const b = calcAngularFreq(undampedFreq, dampingRatio);\n      const c = Math.exp(-delta);\n      return safeMin - a / b * c;\n    };\n\n    derivative = undampedFreq => {\n      const exponentialDecay = undampedFreq * dampingRatio;\n      const delta = exponentialDecay * duration;\n      const d = delta * velocity + velocity;\n      const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n      const f = Math.exp(-delta);\n      const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n      const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n      return factor * ((d - e) * f) / g;\n    };\n  } else {\n    envelope = undampedFreq => {\n      const a = Math.exp(-undampedFreq * duration);\n      const b = (undampedFreq - velocity) * duration + 1;\n      return -safeMin + a * b;\n    };\n\n    derivative = undampedFreq => {\n      const a = Math.exp(-undampedFreq * duration);\n      const b = (velocity - undampedFreq) * (duration * duration);\n      return a * b;\n    };\n  }\n\n  const initialGuess = 5 / duration;\n  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n  duration = duration * 1000;\n\n  if (isNaN(undampedFreq)) {\n    return {\n      stiffness: 100,\n      damping: 10,\n      duration\n    };\n  } else {\n    const stiffness = Math.pow(undampedFreq, 2) * mass;\n    return {\n      stiffness,\n      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n      duration\n    };\n  }\n}\n\nconst rootIterations = 12;\n\nfunction approximateRoot(envelope, derivative, initialGuess) {\n  let result = initialGuess;\n\n  for (let i = 1; i < rootIterations; i++) {\n    result = result - envelope(result) / derivative(result);\n  }\n\n  return result;\n}\n\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\n\nfunction isSpringType(options, keys) {\n  return keys.some(key => options[key] !== undefined);\n}\n\nfunction getSpringOptions(options) {\n  let springOptions = Object.assign({\n    velocity: 0.0,\n    stiffness: 100,\n    damping: 10,\n    mass: 1.0,\n    isResolvedFromDuration: false\n  }, options);\n\n  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {\n    const derived = findSpring(options);\n    springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), {\n      velocity: 0.0,\n      mass: 1.0\n    });\n    springOptions.isResolvedFromDuration = true;\n  }\n\n  return springOptions;\n}\n\nfunction spring(_a) {\n  var {\n    from = 0.0,\n    to = 1.0,\n    restSpeed = 2,\n    restDelta\n  } = _a,\n      options = tslib.__rest(_a, [\"from\", \"to\", \"restSpeed\", \"restDelta\"]);\n\n  const state = {\n    done: false,\n    value: from\n  };\n  let {\n    stiffness,\n    damping,\n    mass,\n    velocity,\n    duration,\n    isResolvedFromDuration\n  } = getSpringOptions(options);\n  let resolveSpring = zero;\n  let resolveVelocity = zero;\n\n  function createSpring() {\n    const initialVelocity = velocity ? -(velocity / 1000) : 0.0;\n    const initialDelta = to - from;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;\n    restDelta !== null && restDelta !== void 0 ? restDelta : restDelta = Math.abs(to - from) <= 1 ? 0.01 : 0.4;\n\n    if (dampingRatio < 1) {\n      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n\n      resolveSpring = t => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));\n      };\n\n      resolveVelocity = t => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        return dampingRatio * undampedAngularFreq * envelope * (Math.sin(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq + initialDelta * Math.cos(angularFreq * t)) - envelope * (Math.cos(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) - angularFreq * initialDelta * Math.sin(angularFreq * t));\n      };\n    } else if (dampingRatio === 1) {\n      resolveSpring = t => to - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    } else {\n      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n\n      resolveSpring = t => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        const freqForT = Math.min(dampedAngularFreq * t, 300);\n        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;\n      };\n    }\n  }\n\n  createSpring();\n  return {\n    next: t => {\n      const current = resolveSpring(t);\n\n      if (!isResolvedFromDuration) {\n        const currentVelocity = resolveVelocity(t) * 1000;\n        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n        const isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;\n        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n      } else {\n        state.done = t >= duration;\n      }\n\n      state.value = state.done ? to : current;\n      return state;\n    },\n    flipTarget: () => {\n      velocity = -velocity;\n      [from, to] = [to, from];\n      createSpring();\n    }\n  };\n}\n\nspring.needsInterpolation = (a, b) => typeof a === \"string\" || typeof b === \"string\";\n\nconst zero = _t => 0;\n\nconst progress = (from, to, value) => {\n  const toFromDifference = to - from;\n  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\n\nconst mix = (from, to, progress) => -progress * from + progress * to + from;\n\nfunction hueToRgb(p, q, t) {\n  if (t < 0) t += 1;\n  if (t > 1) t -= 1;\n  if (t < 1 / 6) return p + (q - p) * 6 * t;\n  if (t < 1 / 2) return q;\n  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n  return p;\n}\n\nfunction hslaToRgba({\n  hue,\n  saturation,\n  lightness,\n  alpha\n}) {\n  hue /= 360;\n  saturation /= 100;\n  lightness /= 100;\n  let red = 0;\n  let green = 0;\n  let blue = 0;\n\n  if (!saturation) {\n    red = green = blue = lightness;\n  } else {\n    const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;\n    const p = 2 * lightness - q;\n    red = hueToRgb(p, q, hue + 1 / 3);\n    green = hueToRgb(p, q, hue);\n    blue = hueToRgb(p, q, hue - 1 / 3);\n  }\n\n  return {\n    red: Math.round(red * 255),\n    green: Math.round(green * 255),\n    blue: Math.round(blue * 255),\n    alpha\n  };\n}\n\nconst mixLinearColor = (from, to, v) => {\n  const fromExpo = from * from;\n  const toExpo = to * to;\n  return Math.sqrt(Math.max(0, v * (toExpo - fromExpo) + fromExpo));\n};\n\nconst colorTypes = [styleValueTypes.hex, styleValueTypes.rgba, styleValueTypes.hsla];\n\nconst getColorType = v => colorTypes.find(type => type.test(v));\n\nconst notAnimatable = color => `'${color}' is not an animatable color. Use the equivalent color code instead.`;\n\nconst mixColor = (from, to) => {\n  let fromColorType = getColorType(from);\n  let toColorType = getColorType(to);\n  heyListen.invariant(!!fromColorType, notAnimatable(from));\n  heyListen.invariant(!!toColorType, notAnimatable(to));\n  let fromColor = fromColorType.parse(from);\n  let toColor = toColorType.parse(to);\n\n  if (fromColorType === styleValueTypes.hsla) {\n    fromColor = hslaToRgba(fromColor);\n    fromColorType = styleValueTypes.rgba;\n  }\n\n  if (toColorType === styleValueTypes.hsla) {\n    toColor = hslaToRgba(toColor);\n    toColorType = styleValueTypes.rgba;\n  }\n\n  const blended = Object.assign({}, fromColor);\n  return v => {\n    for (const key in blended) {\n      if (key !== \"alpha\") {\n        blended[key] = mixLinearColor(fromColor[key], toColor[key], v);\n      }\n    }\n\n    blended.alpha = mix(fromColor.alpha, toColor.alpha, v);\n    return fromColorType.transform(blended);\n  };\n};\n\nconst zeroPoint = {\n  x: 0,\n  y: 0,\n  z: 0\n};\n\nconst isNum = v => typeof v === 'number';\n\nconst combineFunctions = (a, b) => v => b(a(v));\n\nconst pipe = (...transformers) => transformers.reduce(combineFunctions);\n\nfunction getMixer(origin, target) {\n  if (isNum(origin)) {\n    return v => mix(origin, target, v);\n  } else if (styleValueTypes.color.test(origin)) {\n    return mixColor(origin, target);\n  } else {\n    return mixComplex(origin, target);\n  }\n}\n\nconst mixArray = (from, to) => {\n  const output = [...from];\n  const numValues = output.length;\n  const blendValue = from.map((fromThis, i) => getMixer(fromThis, to[i]));\n  return v => {\n    for (let i = 0; i < numValues; i++) {\n      output[i] = blendValue[i](v);\n    }\n\n    return output;\n  };\n};\n\nconst mixObject = (origin, target) => {\n  const output = Object.assign(Object.assign({}, origin), target);\n  const blendValue = {};\n\n  for (const key in output) {\n    if (origin[key] !== undefined && target[key] !== undefined) {\n      blendValue[key] = getMixer(origin[key], target[key]);\n    }\n  }\n\n  return v => {\n    for (const key in blendValue) {\n      output[key] = blendValue[key](v);\n    }\n\n    return output;\n  };\n};\n\nfunction analyse(value) {\n  const parsed = styleValueTypes.complex.parse(value);\n  const numValues = parsed.length;\n  let numNumbers = 0;\n  let numRGB = 0;\n  let numHSL = 0;\n\n  for (let i = 0; i < numValues; i++) {\n    if (numNumbers || typeof parsed[i] === \"number\") {\n      numNumbers++;\n    } else {\n      if (parsed[i].hue !== undefined) {\n        numHSL++;\n      } else {\n        numRGB++;\n      }\n    }\n  }\n\n  return {\n    parsed,\n    numNumbers,\n    numRGB,\n    numHSL\n  };\n}\n\nconst mixComplex = (origin, target) => {\n  const template = styleValueTypes.complex.createTransformer(target);\n  const originStats = analyse(origin);\n  const targetStats = analyse(target);\n  const canInterpolate = originStats.numHSL === targetStats.numHSL && originStats.numRGB === targetStats.numRGB && originStats.numNumbers >= targetStats.numNumbers;\n\n  if (canInterpolate) {\n    return pipe(mixArray(originStats.parsed, targetStats.parsed), template);\n  } else {\n    heyListen.warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n    return p => `${p > 0 ? target : origin}`;\n  }\n};\n\nconst mixNumber = (from, to) => p => mix(from, to, p);\n\nfunction detectMixerFactory(v) {\n  if (typeof v === 'number') {\n    return mixNumber;\n  } else if (typeof v === 'string') {\n    if (styleValueTypes.color.test(v)) {\n      return mixColor;\n    } else {\n      return mixComplex;\n    }\n  } else if (Array.isArray(v)) {\n    return mixArray;\n  } else if (typeof v === 'object') {\n    return mixObject;\n  }\n}\n\nfunction createMixers(output, ease, customMixer) {\n  const mixers = [];\n  const mixerFactory = customMixer || detectMixerFactory(output[0]);\n  const numMixers = output.length - 1;\n\n  for (let i = 0; i < numMixers; i++) {\n    let mixer = mixerFactory(output[i], output[i + 1]);\n\n    if (ease) {\n      const easingFunction = Array.isArray(ease) ? ease[i] : ease;\n      mixer = pipe(easingFunction, mixer);\n    }\n\n    mixers.push(mixer);\n  }\n\n  return mixers;\n}\n\nfunction fastInterpolate([from, to], [mixer]) {\n  return v => mixer(progress(from, to, v));\n}\n\nfunction slowInterpolate(input, mixers) {\n  const inputLength = input.length;\n  const lastInputIndex = inputLength - 1;\n  return v => {\n    let mixerIndex = 0;\n    let foundMixerIndex = false;\n\n    if (v <= input[0]) {\n      foundMixerIndex = true;\n    } else if (v >= input[lastInputIndex]) {\n      mixerIndex = lastInputIndex - 1;\n      foundMixerIndex = true;\n    }\n\n    if (!foundMixerIndex) {\n      let i = 1;\n\n      for (; i < inputLength; i++) {\n        if (input[i] > v || i === lastInputIndex) {\n          break;\n        }\n      }\n\n      mixerIndex = i - 1;\n    }\n\n    const progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v);\n    return mixers[mixerIndex](progressInRange);\n  };\n}\n\nfunction interpolate(input, output, {\n  clamp: isClamp = true,\n  ease,\n  mixer\n} = {}) {\n  const inputLength = input.length;\n  heyListen.invariant(inputLength === output.length, 'Both input and output ranges must be the same length');\n  heyListen.invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, 'Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.');\n\n  if (input[0] > input[inputLength - 1]) {\n    input = [].concat(input);\n    output = [].concat(output);\n    input.reverse();\n    output.reverse();\n  }\n\n  const mixers = createMixers(output, ease, mixer);\n  const interpolator = inputLength === 2 ? fastInterpolate(input, mixers) : slowInterpolate(input, mixers);\n  return isClamp ? v => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;\n}\n\nconst reverseEasing = easing => p => 1 - easing(1 - p);\n\nconst mirrorEasing = easing => p => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\n\nconst createExpoIn = power => p => Math.pow(p, power);\n\nconst createBackIn = power => p => p * p * ((power + 1) * p - power);\n\nconst createAnticipate = power => {\n  const backEasing = createBackIn(power);\n  return p => (p *= 2) < 1 ? 0.5 * backEasing(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n};\n\nconst DEFAULT_OVERSHOOT_STRENGTH = 1.525;\nconst BOUNCE_FIRST_THRESHOLD = 4.0 / 11.0;\nconst BOUNCE_SECOND_THRESHOLD = 8.0 / 11.0;\nconst BOUNCE_THIRD_THRESHOLD = 9.0 / 10.0;\n\nconst linear = p => p;\n\nconst easeIn = createExpoIn(2);\nconst easeOut = reverseEasing(easeIn);\nconst easeInOut = mirrorEasing(easeIn);\n\nconst circIn = p => 1 - Math.sin(Math.acos(p));\n\nconst circOut = reverseEasing(circIn);\nconst circInOut = mirrorEasing(circOut);\nconst backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);\nconst backOut = reverseEasing(backIn);\nconst backInOut = mirrorEasing(backIn);\nconst anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);\nconst ca = 4356.0 / 361.0;\nconst cb = 35442.0 / 1805.0;\nconst cc = 16061.0 / 1805.0;\n\nconst bounceOut = p => {\n  if (p === 1 || p === 0) return p;\n  const p2 = p * p;\n  return p < BOUNCE_FIRST_THRESHOLD ? 7.5625 * p2 : p < BOUNCE_SECOND_THRESHOLD ? 9.075 * p2 - 9.9 * p + 3.4 : p < BOUNCE_THIRD_THRESHOLD ? ca * p2 - cb * p + cc : 10.8 * p * p - 20.52 * p + 10.72;\n};\n\nconst bounceIn = reverseEasing(bounceOut);\n\nconst bounceInOut = p => p < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - p * 2.0)) : 0.5 * bounceOut(p * 2.0 - 1.0) + 0.5;\n\nfunction defaultEasing(values, easing) {\n  return values.map(() => easing || easeInOut).splice(0, values.length - 1);\n}\n\nfunction defaultOffset(values) {\n  const numValues = values.length;\n  return values.map((_value, i) => i !== 0 ? i / (numValues - 1) : 0);\n}\n\nfunction convertOffsetToTimes(offset, duration) {\n  return offset.map(o => o * duration);\n}\n\nfunction keyframes({\n  from = 0,\n  to = 1,\n  ease,\n  offset,\n  duration = 300\n}) {\n  const state = {\n    done: false,\n    value: from\n  };\n  const values = Array.isArray(to) ? to : [from, to];\n  const times = convertOffsetToTimes(offset && offset.length === values.length ? offset : defaultOffset(values), duration);\n\n  function createInterpolator() {\n    return interpolate(times, values, {\n      ease: Array.isArray(ease) ? ease : defaultEasing(values, ease)\n    });\n  }\n\n  let interpolator = createInterpolator();\n  return {\n    next: t => {\n      state.value = interpolator(t);\n      state.done = t >= duration;\n      return state;\n    },\n    flipTarget: () => {\n      values.reverse();\n      interpolator = createInterpolator();\n    }\n  };\n}\n\nfunction decay({\n  velocity = 0,\n  from = 0,\n  power = 0.8,\n  timeConstant = 350,\n  restDelta = 0.5,\n  modifyTarget\n}) {\n  const state = {\n    done: false,\n    value: from\n  };\n  let amplitude = power * velocity;\n  const ideal = from + amplitude;\n  const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n  if (target !== ideal) amplitude = target - from;\n  return {\n    next: t => {\n      const delta = -amplitude * Math.exp(-t / timeConstant);\n      state.done = !(delta > restDelta || delta < -restDelta);\n      state.value = state.done ? target : target + delta;\n      return state;\n    },\n    flipTarget: () => {}\n  };\n}\n\nconst types = {\n  keyframes,\n  spring,\n  decay\n};\n\nfunction detectAnimationFromOptions(config) {\n  if (Array.isArray(config.to)) {\n    return keyframes;\n  } else if (types[config.type]) {\n    return types[config.type];\n  }\n\n  const keys = new Set(Object.keys(config));\n\n  if (keys.has(\"ease\") || keys.has(\"duration\") && !keys.has(\"dampingRatio\")) {\n    return keyframes;\n  } else if (keys.has(\"dampingRatio\") || keys.has(\"stiffness\") || keys.has(\"mass\") || keys.has(\"damping\") || keys.has(\"restSpeed\") || keys.has(\"restDelta\")) {\n    return spring;\n  }\n\n  return keyframes;\n}\n\nfunction loopElapsed(elapsed, duration, delay = 0) {\n  return elapsed - duration - delay;\n}\n\nfunction reverseElapsed(elapsed, duration, delay = 0, isForwardPlayback = true) {\n  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay) : duration - (elapsed - duration) + delay;\n}\n\nfunction hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {\n  return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;\n}\n\nconst framesync = update => {\n  const passTimestamp = ({\n    delta\n  }) => update(delta);\n\n  return {\n    start: () => sync__default['default'].update(passTimestamp, true),\n    stop: () => sync.cancelSync.update(passTimestamp)\n  };\n};\n\nfunction animate(_a) {\n  var _b, _c;\n\n  var {\n    from,\n    autoplay = true,\n    driver = framesync,\n    elapsed = 0,\n    repeat: repeatMax = 0,\n    repeatType = \"loop\",\n    repeatDelay = 0,\n    onPlay,\n    onStop,\n    onComplete,\n    onRepeat,\n    onUpdate\n  } = _a,\n      options = tslib.__rest(_a, [\"from\", \"autoplay\", \"driver\", \"elapsed\", \"repeat\", \"repeatType\", \"repeatDelay\", \"onPlay\", \"onStop\", \"onComplete\", \"onRepeat\", \"onUpdate\"]);\n\n  let {\n    to\n  } = options;\n  let driverControls;\n  let repeatCount = 0;\n  let computedDuration = options.duration;\n  let latest;\n  let isComplete = false;\n  let isForwardPlayback = true;\n  let interpolateFromNumber;\n  const animator = detectAnimationFromOptions(options);\n\n  if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {\n    interpolateFromNumber = interpolate([0, 100], [from, to], {\n      clamp: false\n    });\n    from = 0;\n    to = 100;\n  }\n\n  const animation = animator(Object.assign(Object.assign({}, options), {\n    from,\n    to\n  }));\n\n  function repeat() {\n    repeatCount++;\n\n    if (repeatType === \"reverse\") {\n      isForwardPlayback = repeatCount % 2 === 0;\n      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\n    } else {\n      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\n      if (repeatType === \"mirror\") animation.flipTarget();\n    }\n\n    isComplete = false;\n    onRepeat && onRepeat();\n  }\n\n  function complete() {\n    driverControls.stop();\n    onComplete && onComplete();\n  }\n\n  function update(delta) {\n    if (!isForwardPlayback) delta = -delta;\n    elapsed += delta;\n\n    if (!isComplete) {\n      const state = animation.next(Math.max(0, elapsed));\n      latest = state.value;\n      if (interpolateFromNumber) latest = interpolateFromNumber(latest);\n      isComplete = isForwardPlayback ? state.done : elapsed <= 0;\n    }\n\n    onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);\n\n    if (isComplete) {\n      if (repeatCount === 0) computedDuration !== null && computedDuration !== void 0 ? computedDuration : computedDuration = elapsed;\n\n      if (repeatCount < repeatMax) {\n        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\n      } else {\n        complete();\n      }\n    }\n  }\n\n  function play() {\n    onPlay === null || onPlay === void 0 ? void 0 : onPlay();\n    driverControls = driver(update);\n    driverControls.start();\n  }\n\n  autoplay && play();\n  return {\n    stop: () => {\n      onStop === null || onStop === void 0 ? void 0 : onStop();\n      driverControls.stop();\n    }\n  };\n}\n\nfunction velocityPerSecond(velocity, frameDuration) {\n  return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\n\nfunction inertia({\n  from = 0,\n  velocity = 0,\n  min,\n  max,\n  power = 0.8,\n  timeConstant = 750,\n  bounceStiffness = 500,\n  bounceDamping = 10,\n  restDelta = 1,\n  modifyTarget,\n  driver,\n  onUpdate,\n  onComplete,\n  onStop\n}) {\n  let currentAnimation;\n\n  function isOutOfBounds(v) {\n    return min !== undefined && v < min || max !== undefined && v > max;\n  }\n\n  function boundaryNearest(v) {\n    if (min === undefined) return max;\n    if (max === undefined) return min;\n    return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n  }\n\n  function startAnimation(options) {\n    currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();\n    currentAnimation = animate(Object.assign(Object.assign({}, options), {\n      driver,\n      onUpdate: v => {\n        var _a;\n\n        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v);\n        (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, v);\n      },\n      onComplete,\n      onStop\n    }));\n  }\n\n  function startSpring(options) {\n    startAnimation(Object.assign({\n      type: \"spring\",\n      stiffness: bounceStiffness,\n      damping: bounceDamping,\n      restDelta\n    }, options));\n  }\n\n  if (isOutOfBounds(from)) {\n    startSpring({\n      from,\n      velocity,\n      to: boundaryNearest(from)\n    });\n  } else {\n    let target = power * velocity + from;\n    if (typeof modifyTarget !== \"undefined\") target = modifyTarget(target);\n    const boundary = boundaryNearest(target);\n    const heading = boundary === min ? -1 : 1;\n    let prev;\n    let current;\n\n    const checkBoundary = v => {\n      prev = current;\n      current = v;\n      velocity = velocityPerSecond(v - prev, sync.getFrameData().delta);\n\n      if (heading === 1 && v > boundary || heading === -1 && v < boundary) {\n        startSpring({\n          from: v,\n          to: boundary,\n          velocity\n        });\n      }\n    };\n\n    startAnimation({\n      type: \"decay\",\n      from,\n      velocity,\n      timeConstant,\n      power,\n      restDelta,\n      modifyTarget,\n      onUpdate: isOutOfBounds(target) ? checkBoundary : undefined\n    });\n  }\n\n  return {\n    stop: () => currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop()\n  };\n}\n\nconst radiansToDegrees = radians => radians * 180 / Math.PI;\n\nconst angle = (a, b = zeroPoint) => radiansToDegrees(Math.atan2(b.y - a.y, b.x - a.x));\n\nconst applyOffset = (from, to) => {\n  let hasReceivedFrom = true;\n\n  if (to === undefined) {\n    to = from;\n    hasReceivedFrom = false;\n  }\n\n  return v => {\n    if (hasReceivedFrom) {\n      return v - from + to;\n    } else {\n      from = v;\n      hasReceivedFrom = true;\n      return to;\n    }\n  };\n};\n\nconst identity = v => v;\n\nconst createAttractor = (alterDisplacement = identity) => (constant, origin, v) => {\n  const displacement = origin - v;\n  const springModifiedDisplacement = -(0 - constant + 1) * (0 - alterDisplacement(Math.abs(displacement)));\n  return displacement <= 0 ? origin + springModifiedDisplacement : origin - springModifiedDisplacement;\n};\n\nconst attract = createAttractor();\nconst attractExpo = createAttractor(Math.sqrt);\n\nconst degreesToRadians = degrees => degrees * Math.PI / 180;\n\nconst isPoint = point => point.hasOwnProperty('x') && point.hasOwnProperty('y');\n\nconst isPoint3D = point => isPoint(point) && point.hasOwnProperty('z');\n\nconst distance1D = (a, b) => Math.abs(a - b);\n\nfunction distance(a, b) {\n  if (isNum(a) && isNum(b)) {\n    return distance1D(a, b);\n  } else if (isPoint(a) && isPoint(b)) {\n    const xDelta = distance1D(a.x, b.x);\n    const yDelta = distance1D(a.y, b.y);\n    const zDelta = isPoint3D(a) && isPoint3D(b) ? distance1D(a.z, b.z) : 0;\n    return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));\n  }\n}\n\nconst pointFromVector = (origin, angle, distance) => {\n  angle = degreesToRadians(angle);\n  return {\n    x: distance * Math.cos(angle) + origin.x,\n    y: distance * Math.sin(angle) + origin.y\n  };\n};\n\nconst toDecimal = (num, precision = 2) => {\n  precision = Math.pow(10, precision);\n  return Math.round(num * precision) / precision;\n};\n\nconst smoothFrame = (prevValue, nextValue, duration, smoothing = 0) => toDecimal(prevValue + duration * (nextValue - prevValue) / Math.max(smoothing, duration));\n\nconst smooth = (strength = 50) => {\n  let previousValue = 0;\n  let lastUpdated = 0;\n  return v => {\n    const currentFramestamp = sync.getFrameData().timestamp;\n    const timeDelta = currentFramestamp !== lastUpdated ? currentFramestamp - lastUpdated : 0;\n    const newValue = timeDelta ? smoothFrame(previousValue, v, timeDelta, strength) : previousValue;\n    lastUpdated = currentFramestamp;\n    previousValue = newValue;\n    return newValue;\n  };\n};\n\nconst snap = points => {\n  if (typeof points === 'number') {\n    return v => Math.round(v / points) * points;\n  } else {\n    let i = 0;\n    const numPoints = points.length;\n    return v => {\n      let lastDistance = Math.abs(points[0] - v);\n\n      for (i = 1; i < numPoints; i++) {\n        const point = points[i];\n        const distance = Math.abs(point - v);\n        if (distance === 0) return point;\n        if (distance > lastDistance) return points[i - 1];\n        if (i === numPoints - 1) return point;\n        lastDistance = distance;\n      }\n    };\n  }\n};\n\nfunction velocityPerFrame(xps, frameDuration) {\n  return xps / (1000 / frameDuration);\n}\n\nconst wrap = (min, max, v) => {\n  const rangeSize = max - min;\n  return ((v - min) % rangeSize + rangeSize) % rangeSize + min;\n};\n\nconst a = (a1, a2) => 1.0 - 3.0 * a2 + 3.0 * a1;\n\nconst b = (a1, a2) => 3.0 * a2 - 6.0 * a1;\n\nconst c = a1 => 3.0 * a1;\n\nconst calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n\nconst getSlope = (t, a1, a2) => 3.0 * a(a1, a2) * t * t + 2.0 * b(a1, a2) * t + c(a1);\n\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 10;\n\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n  let currentX;\n  let currentT;\n  let i = 0;\n\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);\n\n  return currentT;\n}\n\nconst newtonIterations = 8;\nconst newtonMinSlope = 0.001;\n\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n  for (let i = 0; i < newtonIterations; ++i) {\n    const currentSlope = getSlope(aGuessT, mX1, mX2);\n\n    if (currentSlope === 0.0) {\n      return aGuessT;\n    }\n\n    const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n\n  return aGuessT;\n}\n\nconst kSplineTableSize = 11;\nconst kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n  if (mX1 === mY1 && mX2 === mY2) return linear;\n  const sampleValues = new Float32Array(kSplineTableSize);\n\n  for (let i = 0; i < kSplineTableSize; ++i) {\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n  }\n\n  function getTForX(aX) {\n    let intervalStart = 0.0;\n    let currentSample = 1;\n    const lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n\n    --currentSample;\n    const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    const guessForT = intervalStart + dist * kSampleStepSize;\n    const initialSlope = getSlope(guessForT, mX1, mX2);\n\n    if (initialSlope >= newtonMinSlope) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  return t => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\nconst steps = (steps, direction = 'end') => progress => {\n  progress = direction === 'end' ? Math.min(progress, 0.999) : Math.max(progress, 0.001);\n  const expanded = progress * steps;\n  const rounded = direction === 'end' ? Math.floor(expanded) : Math.ceil(expanded);\n  return clamp(0, 1, rounded / steps);\n};\n\nexports.angle = angle;\nexports.animate = animate;\nexports.anticipate = anticipate;\nexports.applyOffset = applyOffset;\nexports.attract = attract;\nexports.attractExpo = attractExpo;\nexports.backIn = backIn;\nexports.backInOut = backInOut;\nexports.backOut = backOut;\nexports.bounceIn = bounceIn;\nexports.bounceInOut = bounceInOut;\nexports.bounceOut = bounceOut;\nexports.circIn = circIn;\nexports.circInOut = circInOut;\nexports.circOut = circOut;\nexports.clamp = clamp;\nexports.createAnticipate = createAnticipate;\nexports.createAttractor = createAttractor;\nexports.createBackIn = createBackIn;\nexports.createExpoIn = createExpoIn;\nexports.cubicBezier = cubicBezier;\nexports.decay = decay;\nexports.degreesToRadians = degreesToRadians;\nexports.distance = distance;\nexports.easeIn = easeIn;\nexports.easeInOut = easeInOut;\nexports.easeOut = easeOut;\nexports.inertia = inertia;\nexports.interpolate = interpolate;\nexports.isPoint = isPoint;\nexports.isPoint3D = isPoint3D;\nexports.keyframes = keyframes;\nexports.linear = linear;\nexports.mirrorEasing = mirrorEasing;\nexports.mix = mix;\nexports.mixColor = mixColor;\nexports.mixComplex = mixComplex;\nexports.pipe = pipe;\nexports.pointFromVector = pointFromVector;\nexports.progress = progress;\nexports.radiansToDegrees = radiansToDegrees;\nexports.reverseEasing = reverseEasing;\nexports.smooth = smooth;\nexports.smoothFrame = smoothFrame;\nexports.snap = snap;\nexports.spring = spring;\nexports.steps = steps;\nexports.toDecimal = toDecimal;\nexports.velocityPerFrame = velocityPerFrame;\nexports.velocityPerSecond = velocityPerSecond;\nexports.wrap = wrap;","map":{"version":3,"sources":["C:/Users/Admin/OneDrive/Máy tính/React JS/POS/node_modules/popmotion/dist/popmotion.cjs.js"],"names":["Object","defineProperty","exports","value","tslib","require","heyListen","styleValueTypes","sync","_interopDefaultLegacy","e","sync__default","clamp","min","max","v","Math","safeMin","minDuration","maxDuration","minDamping","maxDamping","findSpring","duration","bounce","velocity","mass","envelope","derivative","warning","dampingRatio","undampedFreq","exponentialDecay","delta","a","b","calcAngularFreq","c","exp","d","pow","f","g","factor","initialGuess","approximateRoot","isNaN","stiffness","damping","sqrt","rootIterations","result","i","durationKeys","physicsKeys","isSpringType","options","keys","some","key","undefined","getSpringOptions","springOptions","assign","isResolvedFromDuration","derived","spring","_a","from","to","restSpeed","restDelta","__rest","state","done","resolveSpring","zero","resolveVelocity","createSpring","initialVelocity","initialDelta","undampedAngularFreq","abs","angularFreq","t","sin","cos","dampedAngularFreq","freqForT","sinh","cosh","next","current","currentVelocity","isBelowVelocityThreshold","isBelowDisplacementThreshold","flipTarget","needsInterpolation","_t","progress","toFromDifference","mix","hueToRgb","p","q","hslaToRgba","hue","saturation","lightness","alpha","red","green","blue","round","mixLinearColor","fromExpo","toExpo","colorTypes","hex","rgba","hsla","getColorType","find","type","test","notAnimatable","color","mixColor","fromColorType","toColorType","invariant","fromColor","parse","toColor","blended","transform","zeroPoint","x","y","z","isNum","combineFunctions","pipe","transformers","reduce","getMixer","origin","target","mixComplex","mixArray","output","numValues","length","blendValue","map","fromThis","mixObject","analyse","parsed","complex","numNumbers","numRGB","numHSL","template","createTransformer","originStats","targetStats","canInterpolate","mixNumber","detectMixerFactory","Array","isArray","createMixers","ease","customMixer","mixers","mixerFactory","numMixers","mixer","easingFunction","push","fastInterpolate","slowInterpolate","input","inputLength","lastInputIndex","mixerIndex","foundMixerIndex","progressInRange","interpolate","isClamp","concat","reverse","interpolator","reverseEasing","easing","mirrorEasing","createExpoIn","power","createBackIn","createAnticipate","backEasing","DEFAULT_OVERSHOOT_STRENGTH","BOUNCE_FIRST_THRESHOLD","BOUNCE_SECOND_THRESHOLD","BOUNCE_THIRD_THRESHOLD","linear","easeIn","easeOut","easeInOut","circIn","acos","circOut","circInOut","backIn","backOut","backInOut","anticipate","ca","cb","cc","bounceOut","p2","bounceIn","bounceInOut","defaultEasing","values","splice","defaultOffset","_value","convertOffsetToTimes","offset","o","keyframes","times","createInterpolator","decay","timeConstant","modifyTarget","amplitude","ideal","types","detectAnimationFromOptions","config","Set","has","loopElapsed","elapsed","delay","reverseElapsed","isForwardPlayback","hasRepeatDelayElapsed","framesync","update","passTimestamp","start","stop","cancelSync","animate","_b","_c","autoplay","driver","repeat","repeatMax","repeatType","repeatDelay","onPlay","onStop","onComplete","onRepeat","onUpdate","driverControls","repeatCount","computedDuration","latest","isComplete","interpolateFromNumber","animator","call","animation","complete","play","velocityPerSecond","frameDuration","inertia","bounceStiffness","bounceDamping","currentAnimation","isOutOfBounds","boundaryNearest","startAnimation","startSpring","boundary","heading","prev","checkBoundary","getFrameData","radiansToDegrees","radians","PI","angle","atan2","applyOffset","hasReceivedFrom","identity","createAttractor","alterDisplacement","constant","displacement","springModifiedDisplacement","attract","attractExpo","degreesToRadians","degrees","isPoint","point","hasOwnProperty","isPoint3D","distance1D","distance","xDelta","yDelta","zDelta","pointFromVector","toDecimal","num","precision","smoothFrame","prevValue","nextValue","smoothing","smooth","strength","previousValue","lastUpdated","currentFramestamp","timestamp","timeDelta","newValue","snap","points","numPoints","lastDistance","velocityPerFrame","xps","wrap","rangeSize","a1","a2","calcBezier","getSlope","subdivisionPrecision","subdivisionMaxIterations","binarySubdivide","aX","aA","aB","mX1","mX2","currentX","currentT","newtonIterations","newtonMinSlope","newtonRaphsonIterate","aGuessT","currentSlope","kSplineTableSize","kSampleStepSize","cubicBezier","mY1","mY2","sampleValues","Float32Array","getTForX","intervalStart","currentSample","lastSample","dist","guessForT","initialSlope","steps","direction","expanded","rounded","floor","ceil"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar tslib = require('tslib');\nvar heyListen = require('hey-listen');\nvar styleValueTypes = require('style-value-types');\nvar sync = require('framesync');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar sync__default = /*#__PURE__*/_interopDefaultLegacy(sync);\n\nconst clamp = (min, max, v) => Math.min(Math.max(v, min), max);\n\nconst safeMin = 0.001;\nconst minDuration = 0.01;\nconst maxDuration = 10.0;\nconst minDamping = 0.05;\nconst maxDamping = 1;\nfunction findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1, }) {\n    let envelope;\n    let derivative;\n    heyListen.warning(duration <= maxDuration * 1000, \"Spring duration must be 10 seconds or less\");\n    let dampingRatio = 1 - bounce;\n    dampingRatio = clamp(minDamping, maxDamping, dampingRatio);\n    duration = clamp(minDuration, maxDuration, duration / 1000);\n    if (dampingRatio < 1) {\n        envelope = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const a = exponentialDecay - velocity;\n            const b = calcAngularFreq(undampedFreq, dampingRatio);\n            const c = Math.exp(-delta);\n            return safeMin - (a / b) * c;\n        };\n        derivative = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const d = delta * velocity + velocity;\n            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n            const f = Math.exp(-delta);\n            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n            return (factor * ((d - e) * f)) / g;\n        };\n    }\n    else {\n        envelope = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (undampedFreq - velocity) * duration + 1;\n            return -safeMin + a * b;\n        };\n        derivative = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (velocity - undampedFreq) * (duration * duration);\n            return a * b;\n        };\n    }\n    const initialGuess = 5 / duration;\n    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n    duration = duration * 1000;\n    if (isNaN(undampedFreq)) {\n        return {\n            stiffness: 100,\n            damping: 10,\n            duration,\n        };\n    }\n    else {\n        const stiffness = Math.pow(undampedFreq, 2) * mass;\n        return {\n            stiffness,\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n            duration,\n        };\n    }\n}\nconst rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n    let result = initialGuess;\n    for (let i = 1; i < rootIterations; i++) {\n        result = result - envelope(result) / derivative(result);\n    }\n    return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = Object.assign({ velocity: 0.0, stiffness: 100, damping: 10, mass: 1.0, isResolvedFromDuration: false }, options);\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        const derived = findSpring(options);\n        springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), { velocity: 0.0, mass: 1.0 });\n        springOptions.isResolvedFromDuration = true;\n    }\n    return springOptions;\n}\nfunction spring(_a) {\n    var { from = 0.0, to = 1.0, restSpeed = 2, restDelta } = _a, options = tslib.__rest(_a, [\"from\", \"to\", \"restSpeed\", \"restDelta\"]);\n    const state = { done: false, value: from };\n    let { stiffness, damping, mass, velocity, duration, isResolvedFromDuration, } = getSpringOptions(options);\n    let resolveSpring = zero;\n    let resolveVelocity = zero;\n    function createSpring() {\n        const initialVelocity = velocity ? -(velocity / 1000) : 0.0;\n        const initialDelta = to - from;\n        const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n        const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;\n        restDelta !== null && restDelta !== void 0 ? restDelta : (restDelta = Math.abs(to - from) <= 1 ? 0.01 : 0.4);\n        if (dampingRatio < 1) {\n            const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n            resolveSpring = (t) => {\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                return (to -\n                    envelope *\n                        (((initialVelocity +\n                            dampingRatio * undampedAngularFreq * initialDelta) /\n                            angularFreq) *\n                            Math.sin(angularFreq * t) +\n                            initialDelta * Math.cos(angularFreq * t)));\n            };\n            resolveVelocity = (t) => {\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                return (dampingRatio *\n                    undampedAngularFreq *\n                    envelope *\n                    ((Math.sin(angularFreq * t) *\n                        (initialVelocity +\n                            dampingRatio *\n                                undampedAngularFreq *\n                                initialDelta)) /\n                        angularFreq +\n                        initialDelta * Math.cos(angularFreq * t)) -\n                    envelope *\n                        (Math.cos(angularFreq * t) *\n                            (initialVelocity +\n                                dampingRatio *\n                                    undampedAngularFreq *\n                                    initialDelta) -\n                            angularFreq *\n                                initialDelta *\n                                Math.sin(angularFreq * t)));\n            };\n        }\n        else if (dampingRatio === 1) {\n            resolveSpring = (t) => to -\n                Math.exp(-undampedAngularFreq * t) *\n                    (initialDelta +\n                        (initialVelocity + undampedAngularFreq * initialDelta) *\n                            t);\n        }\n        else {\n            const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n            resolveSpring = (t) => {\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                const freqForT = Math.min(dampedAngularFreq * t, 300);\n                return (to -\n                    (envelope *\n                        ((initialVelocity +\n                            dampingRatio * undampedAngularFreq * initialDelta) *\n                            Math.sinh(freqForT) +\n                            dampedAngularFreq *\n                                initialDelta *\n                                Math.cosh(freqForT))) /\n                        dampedAngularFreq);\n            };\n        }\n    }\n    createSpring();\n    return {\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                const currentVelocity = resolveVelocity(t) * 1000;\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? to : current;\n            return state;\n        },\n        flipTarget: () => {\n            velocity = -velocity;\n            [from, to] = [to, from];\n            createSpring();\n        },\n    };\n}\nspring.needsInterpolation = (a, b) => typeof a === \"string\" || typeof b === \"string\";\nconst zero = (_t) => 0;\n\nconst progress = (from, to, value) => {\n    const toFromDifference = to - from;\n    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\n\nconst mix = (from, to, progress) => -progress * from + progress * to + from;\n\nfunction hueToRgb(p, q, t) {\n    if (t < 0)\n        t += 1;\n    if (t > 1)\n        t -= 1;\n    if (t < 1 / 6)\n        return p + (q - p) * 6 * t;\n    if (t < 1 / 2)\n        return q;\n    if (t < 2 / 3)\n        return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n}\nfunction hslaToRgba({ hue, saturation, lightness, alpha }) {\n    hue /= 360;\n    saturation /= 100;\n    lightness /= 100;\n    let red = 0;\n    let green = 0;\n    let blue = 0;\n    if (!saturation) {\n        red = green = blue = lightness;\n    }\n    else {\n        const q = lightness < 0.5\n            ? lightness * (1 + saturation)\n            : lightness + saturation - lightness * saturation;\n        const p = 2 * lightness - q;\n        red = hueToRgb(p, q, hue + 1 / 3);\n        green = hueToRgb(p, q, hue);\n        blue = hueToRgb(p, q, hue - 1 / 3);\n    }\n    return {\n        red: Math.round(red * 255),\n        green: Math.round(green * 255),\n        blue: Math.round(blue * 255),\n        alpha,\n    };\n}\n\nconst mixLinearColor = (from, to, v) => {\n    const fromExpo = from * from;\n    const toExpo = to * to;\n    return Math.sqrt(Math.max(0, v * (toExpo - fromExpo) + fromExpo));\n};\nconst colorTypes = [styleValueTypes.hex, styleValueTypes.rgba, styleValueTypes.hsla];\nconst getColorType = (v) => colorTypes.find((type) => type.test(v));\nconst notAnimatable = (color) => `'${color}' is not an animatable color. Use the equivalent color code instead.`;\nconst mixColor = (from, to) => {\n    let fromColorType = getColorType(from);\n    let toColorType = getColorType(to);\n    heyListen.invariant(!!fromColorType, notAnimatable(from));\n    heyListen.invariant(!!toColorType, notAnimatable(to));\n    let fromColor = fromColorType.parse(from);\n    let toColor = toColorType.parse(to);\n    if (fromColorType === styleValueTypes.hsla) {\n        fromColor = hslaToRgba(fromColor);\n        fromColorType = styleValueTypes.rgba;\n    }\n    if (toColorType === styleValueTypes.hsla) {\n        toColor = hslaToRgba(toColor);\n        toColorType = styleValueTypes.rgba;\n    }\n    const blended = Object.assign({}, fromColor);\n    return (v) => {\n        for (const key in blended) {\n            if (key !== \"alpha\") {\n                blended[key] = mixLinearColor(fromColor[key], toColor[key], v);\n            }\n        }\n        blended.alpha = mix(fromColor.alpha, toColor.alpha, v);\n        return fromColorType.transform(blended);\n    };\n};\n\nconst zeroPoint = {\n    x: 0,\n    y: 0,\n    z: 0\n};\nconst isNum = (v) => typeof v === 'number';\n\nconst combineFunctions = (a, b) => (v) => b(a(v));\nconst pipe = (...transformers) => transformers.reduce(combineFunctions);\n\nfunction getMixer(origin, target) {\n    if (isNum(origin)) {\n        return (v) => mix(origin, target, v);\n    }\n    else if (styleValueTypes.color.test(origin)) {\n        return mixColor(origin, target);\n    }\n    else {\n        return mixComplex(origin, target);\n    }\n}\nconst mixArray = (from, to) => {\n    const output = [...from];\n    const numValues = output.length;\n    const blendValue = from.map((fromThis, i) => getMixer(fromThis, to[i]));\n    return (v) => {\n        for (let i = 0; i < numValues; i++) {\n            output[i] = blendValue[i](v);\n        }\n        return output;\n    };\n};\nconst mixObject = (origin, target) => {\n    const output = Object.assign(Object.assign({}, origin), target);\n    const blendValue = {};\n    for (const key in output) {\n        if (origin[key] !== undefined && target[key] !== undefined) {\n            blendValue[key] = getMixer(origin[key], target[key]);\n        }\n    }\n    return (v) => {\n        for (const key in blendValue) {\n            output[key] = blendValue[key](v);\n        }\n        return output;\n    };\n};\nfunction analyse(value) {\n    const parsed = styleValueTypes.complex.parse(value);\n    const numValues = parsed.length;\n    let numNumbers = 0;\n    let numRGB = 0;\n    let numHSL = 0;\n    for (let i = 0; i < numValues; i++) {\n        if (numNumbers || typeof parsed[i] === \"number\") {\n            numNumbers++;\n        }\n        else {\n            if (parsed[i].hue !== undefined) {\n                numHSL++;\n            }\n            else {\n                numRGB++;\n            }\n        }\n    }\n    return { parsed, numNumbers, numRGB, numHSL };\n}\nconst mixComplex = (origin, target) => {\n    const template = styleValueTypes.complex.createTransformer(target);\n    const originStats = analyse(origin);\n    const targetStats = analyse(target);\n    const canInterpolate = originStats.numHSL === targetStats.numHSL &&\n        originStats.numRGB === targetStats.numRGB &&\n        originStats.numNumbers >= targetStats.numNumbers;\n    if (canInterpolate) {\n        return pipe(mixArray(originStats.parsed, targetStats.parsed), template);\n    }\n    else {\n        heyListen.warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n        return (p) => `${p > 0 ? target : origin}`;\n    }\n};\n\nconst mixNumber = (from, to) => (p) => mix(from, to, p);\nfunction detectMixerFactory(v) {\n    if (typeof v === 'number') {\n        return mixNumber;\n    }\n    else if (typeof v === 'string') {\n        if (styleValueTypes.color.test(v)) {\n            return mixColor;\n        }\n        else {\n            return mixComplex;\n        }\n    }\n    else if (Array.isArray(v)) {\n        return mixArray;\n    }\n    else if (typeof v === 'object') {\n        return mixObject;\n    }\n}\nfunction createMixers(output, ease, customMixer) {\n    const mixers = [];\n    const mixerFactory = customMixer || detectMixerFactory(output[0]);\n    const numMixers = output.length - 1;\n    for (let i = 0; i < numMixers; i++) {\n        let mixer = mixerFactory(output[i], output[i + 1]);\n        if (ease) {\n            const easingFunction = Array.isArray(ease) ? ease[i] : ease;\n            mixer = pipe(easingFunction, mixer);\n        }\n        mixers.push(mixer);\n    }\n    return mixers;\n}\nfunction fastInterpolate([from, to], [mixer]) {\n    return (v) => mixer(progress(from, to, v));\n}\nfunction slowInterpolate(input, mixers) {\n    const inputLength = input.length;\n    const lastInputIndex = inputLength - 1;\n    return (v) => {\n        let mixerIndex = 0;\n        let foundMixerIndex = false;\n        if (v <= input[0]) {\n            foundMixerIndex = true;\n        }\n        else if (v >= input[lastInputIndex]) {\n            mixerIndex = lastInputIndex - 1;\n            foundMixerIndex = true;\n        }\n        if (!foundMixerIndex) {\n            let i = 1;\n            for (; i < inputLength; i++) {\n                if (input[i] > v || i === lastInputIndex) {\n                    break;\n                }\n            }\n            mixerIndex = i - 1;\n        }\n        const progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v);\n        return mixers[mixerIndex](progressInRange);\n    };\n}\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\n    const inputLength = input.length;\n    heyListen.invariant(inputLength === output.length, 'Both input and output ranges must be the same length');\n    heyListen.invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, 'Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.');\n    if (input[0] > input[inputLength - 1]) {\n        input = [].concat(input);\n        output = [].concat(output);\n        input.reverse();\n        output.reverse();\n    }\n    const mixers = createMixers(output, ease, mixer);\n    const interpolator = inputLength === 2\n        ? fastInterpolate(input, mixers)\n        : slowInterpolate(input, mixers);\n    return isClamp\n        ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v))\n        : interpolator;\n}\n\nconst reverseEasing = easing => p => 1 - easing(1 - p);\nconst mirrorEasing = easing => p => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\nconst createExpoIn = (power) => p => Math.pow(p, power);\nconst createBackIn = (power) => p => p * p * ((power + 1) * p - power);\nconst createAnticipate = (power) => {\n    const backEasing = createBackIn(power);\n    return p => (p *= 2) < 1\n        ? 0.5 * backEasing(p)\n        : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n};\n\nconst DEFAULT_OVERSHOOT_STRENGTH = 1.525;\nconst BOUNCE_FIRST_THRESHOLD = 4.0 / 11.0;\nconst BOUNCE_SECOND_THRESHOLD = 8.0 / 11.0;\nconst BOUNCE_THIRD_THRESHOLD = 9.0 / 10.0;\nconst linear = p => p;\nconst easeIn = createExpoIn(2);\nconst easeOut = reverseEasing(easeIn);\nconst easeInOut = mirrorEasing(easeIn);\nconst circIn = p => 1 - Math.sin(Math.acos(p));\nconst circOut = reverseEasing(circIn);\nconst circInOut = mirrorEasing(circOut);\nconst backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);\nconst backOut = reverseEasing(backIn);\nconst backInOut = mirrorEasing(backIn);\nconst anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);\nconst ca = 4356.0 / 361.0;\nconst cb = 35442.0 / 1805.0;\nconst cc = 16061.0 / 1805.0;\nconst bounceOut = (p) => {\n    if (p === 1 || p === 0)\n        return p;\n    const p2 = p * p;\n    return p < BOUNCE_FIRST_THRESHOLD\n        ? 7.5625 * p2\n        : p < BOUNCE_SECOND_THRESHOLD\n            ? 9.075 * p2 - 9.9 * p + 3.4\n            : p < BOUNCE_THIRD_THRESHOLD\n                ? ca * p2 - cb * p + cc\n                : 10.8 * p * p - 20.52 * p + 10.72;\n};\nconst bounceIn = reverseEasing(bounceOut);\nconst bounceInOut = (p) => p < 0.5\n    ? 0.5 * (1.0 - bounceOut(1.0 - p * 2.0))\n    : 0.5 * bounceOut(p * 2.0 - 1.0) + 0.5;\n\nfunction defaultEasing(values, easing) {\n    return values.map(() => easing || easeInOut).splice(0, values.length - 1);\n}\nfunction defaultOffset(values) {\n    const numValues = values.length;\n    return values.map((_value, i) => i !== 0 ? i / (numValues - 1) : 0);\n}\nfunction convertOffsetToTimes(offset, duration) {\n    return offset.map((o) => o * duration);\n}\nfunction keyframes({ from = 0, to = 1, ease, offset, duration = 300, }) {\n    const state = { done: false, value: from };\n    const values = Array.isArray(to) ? to : [from, to];\n    const times = convertOffsetToTimes(offset && offset.length === values.length\n        ? offset\n        : defaultOffset(values), duration);\n    function createInterpolator() {\n        return interpolate(times, values, {\n            ease: Array.isArray(ease) ? ease : defaultEasing(values, ease),\n        });\n    }\n    let interpolator = createInterpolator();\n    return {\n        next: (t) => {\n            state.value = interpolator(t);\n            state.done = t >= duration;\n            return state;\n        },\n        flipTarget: () => {\n            values.reverse();\n            interpolator = createInterpolator();\n        },\n    };\n}\n\nfunction decay({ velocity = 0, from = 0, power = 0.8, timeConstant = 350, restDelta = 0.5, modifyTarget, }) {\n    const state = { done: false, value: from };\n    let amplitude = power * velocity;\n    const ideal = from + amplitude;\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n    if (target !== ideal)\n        amplitude = target - from;\n    return {\n        next: (t) => {\n            const delta = -amplitude * Math.exp(-t / timeConstant);\n            state.done = !(delta > restDelta || delta < -restDelta);\n            state.value = state.done ? target : target + delta;\n            return state;\n        },\n        flipTarget: () => { },\n    };\n}\n\nconst types = { keyframes, spring, decay };\nfunction detectAnimationFromOptions(config) {\n    if (Array.isArray(config.to)) {\n        return keyframes;\n    }\n    else if (types[config.type]) {\n        return types[config.type];\n    }\n    const keys = new Set(Object.keys(config));\n    if (keys.has(\"ease\") ||\n        (keys.has(\"duration\") && !keys.has(\"dampingRatio\"))) {\n        return keyframes;\n    }\n    else if (keys.has(\"dampingRatio\") ||\n        keys.has(\"stiffness\") ||\n        keys.has(\"mass\") ||\n        keys.has(\"damping\") ||\n        keys.has(\"restSpeed\") ||\n        keys.has(\"restDelta\")) {\n        return spring;\n    }\n    return keyframes;\n}\n\nfunction loopElapsed(elapsed, duration, delay = 0) {\n    return elapsed - duration - delay;\n}\nfunction reverseElapsed(elapsed, duration, delay = 0, isForwardPlayback = true) {\n    return isForwardPlayback\n        ? loopElapsed(duration + -elapsed, duration, delay)\n        : duration - (elapsed - duration) + delay;\n}\nfunction hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {\n    return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;\n}\n\nconst framesync = (update) => {\n    const passTimestamp = ({ delta }) => update(delta);\n    return {\n        start: () => sync__default['default'].update(passTimestamp, true),\n        stop: () => sync.cancelSync.update(passTimestamp),\n    };\n};\nfunction animate(_a) {\n    var _b, _c;\n    var { from, autoplay = true, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = \"loop\", repeatDelay = 0, onPlay, onStop, onComplete, onRepeat, onUpdate } = _a, options = tslib.__rest(_a, [\"from\", \"autoplay\", \"driver\", \"elapsed\", \"repeat\", \"repeatType\", \"repeatDelay\", \"onPlay\", \"onStop\", \"onComplete\", \"onRepeat\", \"onUpdate\"]);\n    let { to } = options;\n    let driverControls;\n    let repeatCount = 0;\n    let computedDuration = options.duration;\n    let latest;\n    let isComplete = false;\n    let isForwardPlayback = true;\n    let interpolateFromNumber;\n    const animator = detectAnimationFromOptions(options);\n    if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {\n        interpolateFromNumber = interpolate([0, 100], [from, to], {\n            clamp: false,\n        });\n        from = 0;\n        to = 100;\n    }\n    const animation = animator(Object.assign(Object.assign({}, options), { from, to }));\n    function repeat() {\n        repeatCount++;\n        if (repeatType === \"reverse\") {\n            isForwardPlayback = repeatCount % 2 === 0;\n            elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\n        }\n        else {\n            elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\n            if (repeatType === \"mirror\")\n                animation.flipTarget();\n        }\n        isComplete = false;\n        onRepeat && onRepeat();\n    }\n    function complete() {\n        driverControls.stop();\n        onComplete && onComplete();\n    }\n    function update(delta) {\n        if (!isForwardPlayback)\n            delta = -delta;\n        elapsed += delta;\n        if (!isComplete) {\n            const state = animation.next(Math.max(0, elapsed));\n            latest = state.value;\n            if (interpolateFromNumber)\n                latest = interpolateFromNumber(latest);\n            isComplete = isForwardPlayback ? state.done : elapsed <= 0;\n        }\n        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);\n        if (isComplete) {\n            if (repeatCount === 0)\n                computedDuration !== null && computedDuration !== void 0 ? computedDuration : (computedDuration = elapsed);\n            if (repeatCount < repeatMax) {\n                hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\n            }\n            else {\n                complete();\n            }\n        }\n    }\n    function play() {\n        onPlay === null || onPlay === void 0 ? void 0 : onPlay();\n        driverControls = driver(update);\n        driverControls.start();\n    }\n    autoplay && play();\n    return {\n        stop: () => {\n            onStop === null || onStop === void 0 ? void 0 : onStop();\n            driverControls.stop();\n        },\n    };\n}\n\nfunction velocityPerSecond(velocity, frameDuration) {\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\n\nfunction inertia({ from = 0, velocity = 0, min, max, power = 0.8, timeConstant = 750, bounceStiffness = 500, bounceDamping = 10, restDelta = 1, modifyTarget, driver, onUpdate, onComplete, onStop, }) {\n    let currentAnimation;\n    function isOutOfBounds(v) {\n        return (min !== undefined && v < min) || (max !== undefined && v > max);\n    }\n    function boundaryNearest(v) {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    }\n    function startAnimation(options) {\n        currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();\n        currentAnimation = animate(Object.assign(Object.assign({}, options), { driver, onUpdate: (v) => {\n                var _a;\n                onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v);\n                (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, v);\n            }, onComplete,\n            onStop }));\n    }\n    function startSpring(options) {\n        startAnimation(Object.assign({ type: \"spring\", stiffness: bounceStiffness, damping: bounceDamping, restDelta }, options));\n    }\n    if (isOutOfBounds(from)) {\n        startSpring({ from, velocity, to: boundaryNearest(from) });\n    }\n    else {\n        let target = power * velocity + from;\n        if (typeof modifyTarget !== \"undefined\")\n            target = modifyTarget(target);\n        const boundary = boundaryNearest(target);\n        const heading = boundary === min ? -1 : 1;\n        let prev;\n        let current;\n        const checkBoundary = (v) => {\n            prev = current;\n            current = v;\n            velocity = velocityPerSecond(v - prev, sync.getFrameData().delta);\n            if ((heading === 1 && v > boundary) ||\n                (heading === -1 && v < boundary)) {\n                startSpring({ from: v, to: boundary, velocity });\n            }\n        };\n        startAnimation({\n            type: \"decay\",\n            from,\n            velocity,\n            timeConstant,\n            power,\n            restDelta,\n            modifyTarget,\n            onUpdate: isOutOfBounds(target) ? checkBoundary : undefined,\n        });\n    }\n    return {\n        stop: () => currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop(),\n    };\n}\n\nconst radiansToDegrees = (radians) => (radians * 180) / Math.PI;\n\nconst angle = (a, b = zeroPoint) => radiansToDegrees(Math.atan2(b.y - a.y, b.x - a.x));\n\nconst applyOffset = (from, to) => {\n    let hasReceivedFrom = true;\n    if (to === undefined) {\n        to = from;\n        hasReceivedFrom = false;\n    }\n    return (v) => {\n        if (hasReceivedFrom) {\n            return v - from + to;\n        }\n        else {\n            from = v;\n            hasReceivedFrom = true;\n            return to;\n        }\n    };\n};\n\nconst identity = (v) => v;\nconst createAttractor = (alterDisplacement = identity) => (constant, origin, v) => {\n    const displacement = origin - v;\n    const springModifiedDisplacement = -(0 - constant + 1) * (0 - alterDisplacement(Math.abs(displacement)));\n    return displacement <= 0\n        ? origin + springModifiedDisplacement\n        : origin - springModifiedDisplacement;\n};\nconst attract = createAttractor();\nconst attractExpo = createAttractor(Math.sqrt);\n\nconst degreesToRadians = (degrees) => (degrees * Math.PI) / 180;\n\nconst isPoint = (point) => point.hasOwnProperty('x') && point.hasOwnProperty('y');\n\nconst isPoint3D = (point) => isPoint(point) && point.hasOwnProperty('z');\n\nconst distance1D = (a, b) => Math.abs(a - b);\nfunction distance(a, b) {\n    if (isNum(a) && isNum(b)) {\n        return distance1D(a, b);\n    }\n    else if (isPoint(a) && isPoint(b)) {\n        const xDelta = distance1D(a.x, b.x);\n        const yDelta = distance1D(a.y, b.y);\n        const zDelta = isPoint3D(a) && isPoint3D(b) ? distance1D(a.z, b.z) : 0;\n        return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));\n    }\n}\n\nconst pointFromVector = (origin, angle, distance) => {\n    angle = degreesToRadians(angle);\n    return {\n        x: distance * Math.cos(angle) + origin.x,\n        y: distance * Math.sin(angle) + origin.y\n    };\n};\n\nconst toDecimal = (num, precision = 2) => {\n    precision = Math.pow(10, precision);\n    return Math.round(num * precision) / precision;\n};\n\nconst smoothFrame = (prevValue, nextValue, duration, smoothing = 0) => toDecimal(prevValue +\n    (duration * (nextValue - prevValue)) / Math.max(smoothing, duration));\n\nconst smooth = (strength = 50) => {\n    let previousValue = 0;\n    let lastUpdated = 0;\n    return (v) => {\n        const currentFramestamp = sync.getFrameData().timestamp;\n        const timeDelta = currentFramestamp !== lastUpdated ? currentFramestamp - lastUpdated : 0;\n        const newValue = timeDelta\n            ? smoothFrame(previousValue, v, timeDelta, strength)\n            : previousValue;\n        lastUpdated = currentFramestamp;\n        previousValue = newValue;\n        return newValue;\n    };\n};\n\nconst snap = (points) => {\n    if (typeof points === 'number') {\n        return (v) => Math.round(v / points) * points;\n    }\n    else {\n        let i = 0;\n        const numPoints = points.length;\n        return (v) => {\n            let lastDistance = Math.abs(points[0] - v);\n            for (i = 1; i < numPoints; i++) {\n                const point = points[i];\n                const distance = Math.abs(point - v);\n                if (distance === 0)\n                    return point;\n                if (distance > lastDistance)\n                    return points[i - 1];\n                if (i === numPoints - 1)\n                    return point;\n                lastDistance = distance;\n            }\n        };\n    }\n};\n\nfunction velocityPerFrame(xps, frameDuration) {\n    return xps / (1000 / frameDuration);\n}\n\nconst wrap = (min, max, v) => {\n    const rangeSize = max - min;\n    return ((((v - min) % rangeSize) + rangeSize) % rangeSize) + min;\n};\n\nconst a = (a1, a2) => 1.0 - 3.0 * a2 + 3.0 * a1;\nconst b = (a1, a2) => 3.0 * a2 - 6.0 * a1;\nconst c = (a1) => 3.0 * a1;\nconst calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\nconst getSlope = (t, a1, a2) => 3.0 * a(a1, a2) * t * t + 2.0 * b(a1, a2) * t + c(a1);\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 10;\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = aA + (aB - aA) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\n        if (currentX > 0.0) {\n            aB = currentT;\n        }\n        else {\n            aA = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nconst newtonIterations = 8;\nconst newtonMinSlope = 0.001;\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n    for (let i = 0; i < newtonIterations; ++i) {\n        const currentSlope = getSlope(aGuessT, mX1, mX2);\n        if (currentSlope === 0.0) {\n            return aGuessT;\n        }\n        const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n}\nconst kSplineTableSize = 11;\nconst kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    if (mX1 === mY1 && mX2 === mY2)\n        return linear;\n    const sampleValues = new Float32Array(kSplineTableSize);\n    for (let i = 0; i < kSplineTableSize; ++i) {\n        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n    function getTForX(aX) {\n        let intervalStart = 0.0;\n        let currentSample = 1;\n        const lastSample = kSplineTableSize - 1;\n        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n            intervalStart += kSampleStepSize;\n        }\n        --currentSample;\n        const dist = (aX - sampleValues[currentSample]) /\n            (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n        const guessForT = intervalStart + dist * kSampleStepSize;\n        const initialSlope = getSlope(guessForT, mX1, mX2);\n        if (initialSlope >= newtonMinSlope) {\n            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n        }\n        else if (initialSlope === 0.0) {\n            return guessForT;\n        }\n        else {\n            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n        }\n    }\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\nconst steps = (steps, direction = 'end') => (progress) => {\n    progress =\n        direction === 'end' ? Math.min(progress, 0.999) : Math.max(progress, 0.001);\n    const expanded = progress * steps;\n    const rounded = direction === 'end' ? Math.floor(expanded) : Math.ceil(expanded);\n    return clamp(0, 1, rounded / steps);\n};\n\nexports.angle = angle;\nexports.animate = animate;\nexports.anticipate = anticipate;\nexports.applyOffset = applyOffset;\nexports.attract = attract;\nexports.attractExpo = attractExpo;\nexports.backIn = backIn;\nexports.backInOut = backInOut;\nexports.backOut = backOut;\nexports.bounceIn = bounceIn;\nexports.bounceInOut = bounceInOut;\nexports.bounceOut = bounceOut;\nexports.circIn = circIn;\nexports.circInOut = circInOut;\nexports.circOut = circOut;\nexports.clamp = clamp;\nexports.createAnticipate = createAnticipate;\nexports.createAttractor = createAttractor;\nexports.createBackIn = createBackIn;\nexports.createExpoIn = createExpoIn;\nexports.cubicBezier = cubicBezier;\nexports.decay = decay;\nexports.degreesToRadians = degreesToRadians;\nexports.distance = distance;\nexports.easeIn = easeIn;\nexports.easeInOut = easeInOut;\nexports.easeOut = easeOut;\nexports.inertia = inertia;\nexports.interpolate = interpolate;\nexports.isPoint = isPoint;\nexports.isPoint3D = isPoint3D;\nexports.keyframes = keyframes;\nexports.linear = linear;\nexports.mirrorEasing = mirrorEasing;\nexports.mix = mix;\nexports.mixColor = mixColor;\nexports.mixComplex = mixComplex;\nexports.pipe = pipe;\nexports.pointFromVector = pointFromVector;\nexports.progress = progress;\nexports.radiansToDegrees = radiansToDegrees;\nexports.reverseEasing = reverseEasing;\nexports.smooth = smooth;\nexports.smoothFrame = smoothFrame;\nexports.snap = snap;\nexports.spring = spring;\nexports.steps = steps;\nexports.toDecimal = toDecimal;\nexports.velocityPerFrame = velocityPerFrame;\nexports.velocityPerSecond = velocityPerSecond;\nexports.wrap = wrap;\n"]},"metadata":{},"sourceType":"script"}